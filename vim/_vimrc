" vim: fdm=marker isk-==
" because sometime you make mistakes:
" set debug=msg


" JFDI:
" cd ~/.vim
" git clone https://github.com/tpope/vim-pathogen.git pathogen



set nocp
set rtp+=~/.vim/pathogen
" call pathogen#infect()

" infection including:
" rt-client git@github.com:eiro/vim-rt-client
" fugitive  https://github.com/tpope/vim-fugitive.git
" tslime    https://github.com/kikijump/tslime.vim.git
" info      https://github.com/vim-scripts/info.vim.git
" airline   https://github.com/bling/vim-airline.git


" also worth testing (rtp is like zsh $path, update it ...)
" trying to replace pathogen by just rtp+= then 
" set rtp+=~/.vim/bundle/vim-perl
" set rtp+=~/.vim/bundle/airline

" works well with mp_cmd.vim {{{
set aw
nnoremap ,x :make<cr>
" }}}

" i guess it was about python ? {{{
set et
set listchars=tab:>- 
nnoremap ,l :set list!<cr>
" }}}


fun! Scratchpad(...)
    let ft = get( filter( ["a:000[0]","&ft"], "exists(v:val)" ), 0)
    if exists(ft) | exec "let ft = ".ft
    else          | let ft = "default"
    endif
    exec "edit ~/.vim/scratchpad/".ft
    " TODO:
    " au BufNewFile .vim/scratchpad setf expand("%:t")
    " would be smarter as you can reopen the scratchpad manually
    exec "setf ".ft
endf 
command -nargs=* -complete=filetype Scratchpad call Scratchpad(<f-args>)

command -nargs=1 -complete=command Sh
    \| let g:ShPwd=getcwd()
    \| exec "cd ". <q-args> 
    \| exec "!zsh"
    \| exec "cd ".g:ShPwd

command -nargs=* Perldoc wincmd n 
    \| setf man
    \| silent 0r!perldoc -t <args> || perldoc -t -f <args>

" recent/experimental additions {{{

" pour les buffermenues

" hi CursorLine ctermfg=white ctermbg=red

" nnoremap ,K :exec 'Man '.expand('<cfile>')<cr>
" shell programming 
" set isfname-==
" command -nargs=* SyntaxIdEcho echo synIDattr(synID(line("."), col("."), 1), "name")
" command -nargs=* GIT echo system('git '.<q-args>)

" }}}
" General settings {{{
" :h 'lz' for help on lz
" and so on ...
" as summary, my vim is 
" (nocp) not compatible with vi 
" (vb)  don't beep (screen flash instead)
" (lz)  don't refresh when busy with macros
" (hid) don't abandon buffers 
" (ai)  autoindent
" (lbr) don't wrap in a middle of a word
" (so)  cursor try to stay at the middle of the screen
" (ul)  you can undo ... x times 
" (wim) command line completion show you a list 
"       and let you decide
" (ff)  gain 1 octet by line ;)
" (ml)  honor modlines (vim: configuration in the current file)
" (is)  next match for the RE you're typing
" (hls) all matches of the last RE

set nocp vb lz ai lbr ml hid hls is
set sw=4 ul=1000 wim=longest,list so=999 ff=unix dy=uhex

" no timeout for mapping sequences
set notimeout nottimeout 
" always want status bar
set laststatus=2
set spf=~/.vim/spell/mine.latin1.add
" "set statusline=%F%m%r%h%w\ [ff=%{&ff},ft=%Y][ascii=\%03.3b,hex=\%02.2B](y=%04l,vx=%04v)
set dictionary+=~/.vim/dicts/tt2,~/.vim/dicts/html

syn on
filetype on
filetype indent plugin on

if has("digraphs")
    digraphs .3 8230
endif

" :Tohtml use CSS  
let html_use_css='yes'
" }}}
" GUI and windows settings {{{
" TODO: search and destroy ? 
let g:WINDOWSVERSION = 0
for windowsversion in [ 'win16' , 'win32' , 'win64' , 'win95' , 'win32unix' ]
	if has(windowsversion)
		let g:WINDOWSVERSION = windowsversion
		break
	endif
endfor
if g:WINDOWSVERSION 
  " alt keys are also used by vim
  set wak=yes
  map <silent> <m-space> <esc>c>:simalt ~<cr>>
else
  run ftplugin/man.vim
  set wak=no
endif
if has("gui_running")
  set go=agrLt
  colorscheme elflord
  " colorscheme darkblue
  " go=MAac seems to be good on windows
  if has("gui_win32")
      set guifont=Lucida_Console:h10:cANSI
  else 
      set guifont=Monospace\ 13
  endif
else
  " elflord and evening are cool too ! 
  " colorscheme ron
  " colorscheme darkblue
  " set background=light
endif
" }}}
" recommended by cmd_mp.vim {{{
set aw
nnoremap ,x :make<cr>
" }}}
" programmers {{{
let mapleader='('
" }}}
" personnal filetypes {{{
au BufNewFile *.xsl 0r~/.vim/templates/xsl.xsl
au BufNewFile *.pl,*.t 0r~/.vim/templates/perl.pl | norm G
au BufNewFile *.pm 0r~/.vim/templates/perl.pm 
au BufRead slapd.conf setf slapd
au BufRead *.go setf go
au BufRead *.psgi setf perl
au BufRead *.ferm,*ferm.conf setf ferm
au BufNewFile,BufRead */itsalltext/wiki.* setf dokuwiki

au BufNewFile,BufRead *mutt/* if ! &ft | set ft=muttrc | endif
au BufNewFile,BufRead *.tt2.*,tt2.*,*.tt2 runtime macros/tt2.vim
au BufNewFile,BufRead *.tt2html
			\ set ft=html |
			\ runtime macros/tt2.vim
au BufNewFile *.html 0r ~/.vim/templates/html5.html

au BufRead psql.edit* setf sql

au BufNewFile,BufRead * exec 'setlocal dict+=~/.vim/dicts/'.&ft.'/*'
au BufNewFile,BufRead Vagrantfile setf ruby
" }}}
" lovely long parentheses indent in C too :)
set cino=(s,m1

function FoldParagraph ()
    " pompé de :h foldexp
    return getline(v:lnum)=~'^\s*$'&&getline(v:lnum+1)=~'\S'?'<1':1
endfunction

fu! NewFoldWhenLineMatches( lineMatches )
  if getline( v:lnum ) =~ '\v^\s*(#|$)'
    return '='
  endif

  if getline( v:lnum ) =~ a:lineMatches
    return 'a1'
  elseif getline( v:lnum + 1 ) =~ a:lineMatches 
    return 's1'
  endif

  return '='
endfu 

iab cdlt, cordialement,

fun! NewFilter ( alias, filter )
    " filter inplace (c as in change, cw)
    exec "nmap ,c" . a:alias . "  :%!". a:filter . "<cr>"
    exec "vm   ,c" . a:alias . "  :!" . a:filter . "<cr>"
    " new window (w as in window) 
    exec "nmap ,w" . a:alias . "  ,wnp,c"  . a:alias . ""
    exec "vm   ,w" . a:alias . "  ,wnp,c" . a:alias . ""
    " filter on paste
    exec "vm   ,f" . a:alias . "  yPgv,c" . a:alias . ""
endf

" all the file or the visual selection can be piped to 
" which means (see NewFilter): 
" ,wz open a new window with the result of a zsh filtering 
call NewFilter('z','zsh')
call NewFilter('5','perl')
call NewFilter('6','perl6')
call NewFilter('t','textile')

" echo map(['j','s','n','l','qu'],"\"inoremap v:val ' v:val <c-k>'9")
" inoremap j' j<c-k>'9
" inoremap s' s<c-k>'9
" inoremap n' n<c-k>'9
" inoremap s' s<c-k>'9
" inoremap l' l<c-k>'9
" inoremap qu' qu<c-k>'9

com -complete=custom,ListUsers -nargs=1 Shoot :wincmd new|<args>
fun ListUsers(A,L,P)
    return system("cat ~/.vim/rt/users")
endfun

nnoremap ,m :let @/='X'<cr><c-w><c-n>:setf mail<cr>:0r~/.vim/mutt_drafts/

com!  -complete=filetype -nargs=1 Sp wincmd n | setf <args>

set colorcolumn=80
